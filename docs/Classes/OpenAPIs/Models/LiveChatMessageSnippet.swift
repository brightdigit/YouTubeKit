//
// LiveChatMessageSnippet.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable

public struct LiveChatMessageSnippet: Codable, Hashable {

    public enum ModelType: String, Codable, CaseIterable {
        case invalidtype = "invalidType"
        case textmessageevent = "textMessageEvent"
        case tombstone = "tombstone"
        case fanfundingevent = "fanFundingEvent"
        case chatendedevent = "chatEndedEvent"
        case sponsoronlymodestartedevent = "sponsorOnlyModeStartedEvent"
        case sponsoronlymodeendedevent = "sponsorOnlyModeEndedEvent"
        case newsponsorevent = "newSponsorEvent"
        case messagedeletedevent = "messageDeletedEvent"
        case messageretractedevent = "messageRetractedEvent"
        case userbannedevent = "userBannedEvent"
        case superchatevent = "superChatEvent"
        case superstickerevent = "superStickerEvent"
    }
    /** The ID of the user that authored this message, this field is not always filled. textMessageEvent - the user that wrote the message fanFundingEvent - the user that funded the broadcast newSponsorEvent - the user that just became a sponsor messageDeletedEvent - the moderator that took the action messageRetractedEvent - the author that retracted their message userBannedEvent - the moderator that took the action superChatEvent - the user that made the purchase */
    public var authorChannelId: String?
    /** Contains a string that can be displayed to the user. If this field is not present the message is silent, at the moment only messages of type TOMBSTONE and CHAT_ENDED_EVENT are silent. */
    public var displayMessage: String?
    public var fanFundingEventDetails: LiveChatFanFundingEventDetails?
    /** Whether the message has display content that should be displayed to users. */
    public var hasDisplayContent: Bool?
    public var liveChatId: String?
    public var messageDeletedDetails: LiveChatMessageDeletedDetails?
    public var messageRetractedDetails: LiveChatMessageRetractedDetails?
    /** The date and time when the message was orignally published. */
    public var publishedAt: Date?
    public var superChatDetails: LiveChatSuperChatDetails?
    public var superStickerDetails: LiveChatSuperStickerDetails?
    public var textMessageDetails: LiveChatTextMessageDetails?
    /** The type of message, this will always be present, it determines the contents of the message as well as which fields will be present. */
    public var type: ModelType?
    public var userBannedDetails: LiveChatUserBannedMessageDetails?

    public init(authorChannelId: String? = nil, displayMessage: String? = nil, fanFundingEventDetails: LiveChatFanFundingEventDetails? = nil, hasDisplayContent: Bool? = nil, liveChatId: String? = nil, messageDeletedDetails: LiveChatMessageDeletedDetails? = nil, messageRetractedDetails: LiveChatMessageRetractedDetails? = nil, publishedAt: Date? = nil, superChatDetails: LiveChatSuperChatDetails? = nil, superStickerDetails: LiveChatSuperStickerDetails? = nil, textMessageDetails: LiveChatTextMessageDetails? = nil, type: ModelType? = nil, userBannedDetails: LiveChatUserBannedMessageDetails? = nil) {
        self.authorChannelId = authorChannelId
        self.displayMessage = displayMessage
        self.fanFundingEventDetails = fanFundingEventDetails
        self.hasDisplayContent = hasDisplayContent
        self.liveChatId = liveChatId
        self.messageDeletedDetails = messageDeletedDetails
        self.messageRetractedDetails = messageRetractedDetails
        self.publishedAt = publishedAt
        self.superChatDetails = superChatDetails
        self.superStickerDetails = superStickerDetails
        self.textMessageDetails = textMessageDetails
        self.type = type
        self.userBannedDetails = userBannedDetails
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case authorChannelId
        case displayMessage
        case fanFundingEventDetails
        case hasDisplayContent
        case liveChatId
        case messageDeletedDetails
        case messageRetractedDetails
        case publishedAt
        case superChatDetails
        case superStickerDetails
        case textMessageDetails
        case type
        case userBannedDetails
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(authorChannelId, forKey: .authorChannelId)
        try container.encodeIfPresent(displayMessage, forKey: .displayMessage)
        try container.encodeIfPresent(fanFundingEventDetails, forKey: .fanFundingEventDetails)
        try container.encodeIfPresent(hasDisplayContent, forKey: .hasDisplayContent)
        try container.encodeIfPresent(liveChatId, forKey: .liveChatId)
        try container.encodeIfPresent(messageDeletedDetails, forKey: .messageDeletedDetails)
        try container.encodeIfPresent(messageRetractedDetails, forKey: .messageRetractedDetails)
        try container.encodeIfPresent(publishedAt, forKey: .publishedAt)
        try container.encodeIfPresent(superChatDetails, forKey: .superChatDetails)
        try container.encodeIfPresent(superStickerDetails, forKey: .superStickerDetails)
        try container.encodeIfPresent(textMessageDetails, forKey: .textMessageDetails)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(userBannedDetails, forKey: .userBannedDetails)
    }



}
